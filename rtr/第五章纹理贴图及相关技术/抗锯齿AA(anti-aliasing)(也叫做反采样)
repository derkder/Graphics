https://zhuanlan.zhihu.com/p/415087003
锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有"问题，丢失了连续性的信息，导致锯齿。
rtr上的锯齿来源：高分辨率的信号以低分辨率表示或无法准确运算出3D图形坐标定位时所导致的图形混叠（aliasing）而产生的。

一、SSAA（Super Sampling AA）
拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。
这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。
【下采样：缩小图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值】

二、MSAA（Multi-Sampling AA）
也是在每个像素中进行多次采样，然后根据多次采样的结果综合来计算像素的颜色值。
但只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。
出于性能考虑，同一个像素上的多个次像素点，不会每个都进行一次像素着色计算，而是共享像素中心点的像素计算结果。对于每个像素点，如果上面对应的次像素点至少有一个次像素点通过了覆盖测试(下图中圆圈位置)，就会进行一次采样，计算的插值采样位置是像素的中心位置(下面图中的菱形块)。一次采样的结果，会用于多个次像素采样点中。


三、FXAA、SMAA
通过后处理的方式，寻找屏幕中的像素块边界，然后根据边界的信息，将两侧的像素点颜色进行插值，这样就会得到平滑过渡的边缘，实现抗锯齿的效果。
开销固定，不会因为绘制物体的多少而影响开销。




https://www.yuque.com/unrealengine/graphics/retdci#L5SfF
games101区分SSAA和MSAA
区分一下两者，然后再看怎么操作。都是以4x为例
● 4xSSAA，超级取样抗锯齿
  ○ 每个像素维护一个4x子像素的颜色和深度列表
  ○ 在子像素上进行所有的计算
  ○ 最后在显示阶段，平均一下子像素，输出给显示器
● 4xMSAA，多重取样抗锯齿（每个像素还是只计算一次，不会计算四次的）
  ○ 每个像素维护一个4x子像素的颜色和深度列表
  ○ 通过子像素的在三角形内的覆盖率对父像素颜色进行平均//!!
  ○ 最后在显示阶段，直接输出给显示器//!!
    感觉就是相比上面，只看三角形覆盖的
    rtr:后者相对于前者，只对多边形的边缘进行抗锯齿处理



FXAA的具体做法：(后处理)
1. 检测锯齿
FXAA首先会检测图像中的锯齿和走样现象，它通过分析相邻像素之间的亮度变化来检测锯齿，如果发现某些像素之间的亮度变化超过了阈值，则认为这些像素之间存在锯齿。
2. 模糊处理
一旦检测到锯齿，FXAA会对锯齿部分进行模糊处理，以模糊锯齿边缘，从而达到抗锯齿的效果。具体来说，它使用一个卷积核对图像进行模糊处理，卷积核的大小和权重是固定的，并且是经过优化的，以使FXAA能够快速地在GPU上执行。
3. 防止过度模糊
由于模糊处理会导致图像变得模糊，因此FXAA还会对图像进行一定程度的锐化处理，以避免过度模糊。锐化处理可以增强图像的边缘，使其更加清晰，但需要注意的是，如果锐化过度，也会导致图像出现过度锐化的现象。




MSAA为什么对延迟渲染不友好：
一个是MSAA本质上是一种发生在光栅化阶段的技术，也就是几何阶段后，着色阶段前，这个技术需要用到场景中的几何信息，但是延迟渲染因为需要节省光照计算的原因，事先把所有信息都放在了GBuffer上，着色计算的时候已经丢失了几何信息；
而且关键一点是如果强行这么做，MSAA会增加数倍的带宽性能消耗，因此一般都不会这么做。
还有一个原因是是以前DX9的时代，MRT(多重渲染目标)技术不支持MSAA。





卷积的简化定义：结果为相邻数的平均值
