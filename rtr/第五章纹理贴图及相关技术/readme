各种贴图与AA


抗锯齿技术可以从原理上分为两个大类：空域抗锯齿和时域抗锯齿。空域抗锯齿的代表是FXAA和SMAA，时域抗锯齿的代表就是TAA。





Super Sampling（超采样）和Anti-Aliasing（抗锯齿）的区别：
Super Sampling是一种更为基础的技术，它通过在渲染时对图像进行更高分辨率的采样来减少锯齿和走样的现象。在超采样中，渲染时将每个像素细分为多个子像素，并在这些子像素上进行渲染，
然后将结果合并成一个像素。由于子像素数量更多，因此可以获得更精细的图像，从而减少锯齿和走样的现象。常见的超采样技术包括MSAA（Multisample Anti-Aliasing）和SSAA（Super Sampling Anti-Aliasing）。

Anti-Aliasing则是一种更为高级的技术，它通过对像素的颜色进行插值、平滑等处理来减少锯齿和走样的现象。由于不需要对每个像素进行更多子像素的渲染，因此Anti-Aliasing对性能的影响更小。
常见的抗锯齿技术包括FXAA（Fast Approximate Anti-Aliasing）、SMAA（Subpixel Morphological Anti-Aliasing）和TAA（Temporal Anti-Aliasing）等。


总的来说，Super Sampling和Anti-Aliasing都可以有效减少锯齿和走样的现象，但Super Sampling需要更多的计算资源，而Anti-Aliasing则更加高效。在具体应用中，可以根据需要选择合适的技术并进行优化，以获得更好的结果。


MSAA与SSAA的区别貌似就是最简单的版本:
SSAA 对整个场景进行超采样，而 MSAA 只对几何边缘进行多重采样。[!这里的采样指的是一个像素的四个采样点，看这个采样点有没有被图元覆盖!]【感觉也不是前面说的，好像就是以四倍的分辨率做光栅化但是不是每个采样点都走片元着色器，而是会把结果写在缓冲区上，然后片元着色器还是以原来的分辨率走，然后会平均那四个着色点的颜色】
上面是常见的说法，我认为，大错特错了！ SSAA是先用x倍的分辨率进行渲染再下采样，而MSAA只是在光栅化和片段着色阶段进行多重采样[!这里的采样指的是一个像素上四个采样点，对于每个采样点，看他有没有被图元覆盖到!]。
具体：
！那这个只对边缘进行是怎么实现的呢！：
首先是Coverage Test。计算当前像素的Sample点被该三角形覆盖了几个，当被覆盖Sample点数量>0的情况下，像素着色器才会被执行，这就意为着开启MSAA之后并不是Per Sample shading，而是per Pixel shading
然后还会进行深度模板测试，都通过才会写入color buffer
1. 多重采样光栅化
在光栅化阶段，MSAA 对每个像素的多个子像素进行采样。每个像素被划分为多个子像素（例如 4x MSAA 意味着每个像素有 4 个子像素）。光栅化阶段的具体步骤如下：
  子像素采样：对于每个像素，确定其包含的多个子像素的位置。
  覆盖测试：对于每个子像素，检查它是否被图元覆盖。这一步通常通过计算子像素的坐标是否在图元内部来实现。
2. 片段着色
在片段着色阶段，MSAA 只对每个像素进行一次着色计算，而不是对每个子像素进行着色。具体步骤如下：
  单次着色：对每个像素进行一次着色计算，得到一个颜色值。
  颜色存储：将这个颜色值存储在每个子像素中。
3. 输出合并
在输出合并阶段，MSAA 将每个像素的多个子像素的颜色值进行平均，得到最终的像素颜色。具体步骤如下：
  颜色平均：对每个像素的多个子像素的颜色值进行平均，得到最终的像素颜色。
  写入帧缓冲区：将最终的像素颜色写入帧缓冲区。


附：
  光栅化渲染的基本流程
    顶点着色：将顶点从模型空间转换到屏幕空间。
    图元装配：将顶点组装成图元（如三角形）。
    光栅化：将图元转换为屏幕上的像素。
    片段着色：对每个像素进行着色计算。
    输出合并：将片段的颜色值写入帧缓冲区。
https://www.cnblogs.com/ghl_carmack/p/8245032.html
