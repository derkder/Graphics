正向渲染
简述：
  先进行着色，再进行深度测试(Z-Buffer)。其的主要缺点就是光照计算跟场景复杂度和光源个数有很大关系。假设有 n 个物体，m 个光源，且每个每个物体受所有光源的影响，那么复杂度就是 O(m*n)。
  也就是每个作用于物体的像素光单独计算一次，drawCall随着物体与光照数量增加而成倍增加
优点：
  不受硬件限制
缺点：
  每个物体接受光照数量有限。




延迟渲染【G-Buffer空间换时间】
简述：
  物体颜色、法线、材质等信息先渲染到G-Buffer中，光照最后单独渲染，避免每个物体多个光照批次的问题。为 O(n+m)。
  也就是就是将光照/渲染的计算延迟到第二步进行，避免多次渲染同一个像素
优点：
  • 复杂度仅 O(n+m)。
  • 只渲染可见的像素，节省计算量。
  • 用更少的 shader。
  • 对后处理支持良好。
  • 在大量光源的场景优势尤其明显
缺点：
  • 内存开销较大。
  • 读写 G-buffer 的内存带宽用量是性能瓶颈。
  • 对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染。【半透明物体仍然使用前向渲染。】
  • 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启 MRT。
  • 移动设备需要支持OpenGL3.0。



为什么不都用延迟渲染：
不支持msaa、半透物体（因为gbuffer上只能存一个）、硬件支持、高内存占用（gbuffer）

