https://zhuanlan.zhihu.com/p/415087003
锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有"问题，丢失了连续性的信息，导致锯齿。


一、SSAA（Super Sampling AA）
拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。
这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。
【下采样：缩小图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值】

二、MSAA（Multi-Sampling AA）
也是在每个像素中进行多次采样，然后根据多次采样的结果综合来计算像素的颜色值。
但只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。
出于性能考虑，同一个像素上的多个次像素点，不会每个都进行一次像素着色计算，而是共享像素中心点的像素计算结果。对于每个像素点，如果上面对应的次像素点至少有一个次像素点通过了覆盖测试(下图中圆圈位置)，就会进行一次采样，计算的插值采样位置是像素的中心位置(下面图中的菱形块)。一次采样的结果，会用于多个次像素采样点中。


三、FXAA、SMAA
通过后处理的方式，寻找屏幕中的像素块边界，然后根据边界的信息，将两侧的像素点颜色进行插值，这样就会得到平滑过渡的边缘，实现抗锯齿的效果。
开销固定，不会因为绘制物体的多少而影响开销。




https://www.yuque.com/unrealengine/graphics/retdci#L5SfF
games101区分SSAA和MSAA
区分一下两者，然后再看怎么操作。都是以4x为例
● 4xSSAA，超级取样抗锯齿
  ○ 每个像素维护一个4x子像素的颜色和深度列表
  ○ 在子像素上进行所有的计算
  ○ 最后在显示阶段，平均一下子像素，输出给显示器
● 4xMSAA，多重取样抗锯齿
  ○ 每个像素维护一个4x子像素的颜色和深度列表
  ○ 通过子像素的在三角形内的覆盖率对父像素颜色进行平均//!!
  ○ 最后在显示阶段，直接输出给显示器//!!
    感觉就是相比上面，只看三角形覆盖的














卷积的简化定义：结果为相邻数的平均值
